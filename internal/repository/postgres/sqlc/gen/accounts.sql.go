// ErrCode generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createAccountForUser = `-- name: CreateAccountForUser :one
INSERT INTO accounts (user_id, public_code, level_code)
VALUES ($1, $2, $3)
RETURNING
    id, user_id, public_code, created_at,
    balance_points, total_spend_money,
    COALESCE(level_code, '')::text AS level_code
`

type CreateAccountForUserParams struct {
	UserID     int64
	PublicCode string
	LevelCode  pgtype.Text
}

type CreateAccountForUserRow struct {
	ID              int64
	UserID          int64
	PublicCode      string
	CreatedAt       pgtype.Timestamptz
	BalancePoints   int32
	TotalSpendMoney decimal.Decimal
	LevelCode       string
}

func (q *Queries) CreateAccountForUser(ctx context.Context, db DBTX, arg CreateAccountForUserParams) (CreateAccountForUserRow, error) {
	row := db.QueryRow(ctx, createAccountForUser, arg.UserID, arg.PublicCode, arg.LevelCode)
	var i CreateAccountForUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicCode,
		&i.CreatedAt,
		&i.BalancePoints,
		&i.TotalSpendMoney,
		&i.LevelCode,
	)
	return i, err
}

const getAccountByPublicCode = `-- name: GetAccountByPublicCode :one
SELECT
    id, user_id, public_code, created_at,
    balance_points, total_spend_money,
    COALESCE(level_code, '')::text AS level_code
FROM accounts
WHERE public_code = $1
`

type GetAccountByPublicCodeRow struct {
	ID              int64
	UserID          int64
	PublicCode      string
	CreatedAt       pgtype.Timestamptz
	BalancePoints   int32
	TotalSpendMoney decimal.Decimal
	LevelCode       string
}

func (q *Queries) GetAccountByPublicCode(ctx context.Context, db DBTX, publicCode string) (GetAccountByPublicCodeRow, error) {
	row := db.QueryRow(ctx, getAccountByPublicCode, publicCode)
	var i GetAccountByPublicCodeRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicCode,
		&i.CreatedAt,
		&i.BalancePoints,
		&i.TotalSpendMoney,
		&i.LevelCode,
	)
	return i, err
}

const getAccountByUserID = `-- name: GetAccountByUserID :one
SELECT
    id, user_id, public_code, created_at,
    balance_points, total_spend_money,
    COALESCE(level_code, '')::text AS level_code
FROM accounts
WHERE user_id = $1
`

type GetAccountByUserIDRow struct {
	ID              int64
	UserID          int64
	PublicCode      string
	CreatedAt       pgtype.Timestamptz
	BalancePoints   int32
	TotalSpendMoney decimal.Decimal
	LevelCode       string
}

func (q *Queries) GetAccountByUserID(ctx context.Context, db DBTX, userID int64) (GetAccountByUserIDRow, error) {
	row := db.QueryRow(ctx, getAccountByUserID, userID)
	var i GetAccountByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicCode,
		&i.CreatedAt,
		&i.BalancePoints,
		&i.TotalSpendMoney,
		&i.LevelCode,
	)
	return i, err
}

const lockAccountByID = `-- name: LockAccountByID :one
SELECT
    id, user_id, public_code, created_at,
    balance_points, total_spend_money,
    COALESCE(level_code, '')::text AS level_code
FROM accounts
WHERE id = $1
    FOR UPDATE
`

type LockAccountByIDRow struct {
	ID              int64
	UserID          int64
	PublicCode      string
	CreatedAt       pgtype.Timestamptz
	BalancePoints   int32
	TotalSpendMoney decimal.Decimal
	LevelCode       string
}

func (q *Queries) LockAccountByID(ctx context.Context, db DBTX, id int64) (LockAccountByIDRow, error) {
	row := db.QueryRow(ctx, lockAccountByID, id)
	var i LockAccountByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicCode,
		&i.CreatedAt,
		&i.BalancePoints,
		&i.TotalSpendMoney,
		&i.LevelCode,
	)
	return i, err
}

const updateAccountAfterEarn = `-- name: UpdateAccountAfterEarn :one
UPDATE accounts
SET
    balance_points = $2,
    total_spend_money = $3,
    level_code = $4
WHERE id = $1
RETURNING
    id, user_id, public_code, created_at,
    balance_points, total_spend_money,
    COALESCE(level_code, '')::text AS level_code
`

type UpdateAccountAfterEarnParams struct {
	ID              int64
	BalancePoints   int32
	TotalSpendMoney decimal.Decimal
	LevelCode       pgtype.Text
}

type UpdateAccountAfterEarnRow struct {
	ID              int64
	UserID          int64
	PublicCode      string
	CreatedAt       pgtype.Timestamptz
	BalancePoints   int32
	TotalSpendMoney decimal.Decimal
	LevelCode       string
}

func (q *Queries) UpdateAccountAfterEarn(ctx context.Context, db DBTX, arg UpdateAccountAfterEarnParams) (UpdateAccountAfterEarnRow, error) {
	row := db.QueryRow(ctx, updateAccountAfterEarn,
		arg.ID,
		arg.BalancePoints,
		arg.TotalSpendMoney,
		arg.LevelCode,
	)
	var i UpdateAccountAfterEarnRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicCode,
		&i.CreatedAt,
		&i.BalancePoints,
		&i.TotalSpendMoney,
		&i.LevelCode,
	)
	return i, err
}

const updateAccountAfterSpend = `-- name: UpdateAccountAfterSpend :one
UPDATE accounts
SET balance_points = $2
WHERE id = $1
RETURNING
    id, user_id, public_code, created_at,
    balance_points, total_spend_money,
    COALESCE(level_code, '')::text AS level_code
`

type UpdateAccountAfterSpendParams struct {
	ID            int64
	BalancePoints int32
}

type UpdateAccountAfterSpendRow struct {
	ID              int64
	UserID          int64
	PublicCode      string
	CreatedAt       pgtype.Timestamptz
	BalancePoints   int32
	TotalSpendMoney decimal.Decimal
	LevelCode       string
}

func (q *Queries) UpdateAccountAfterSpend(ctx context.Context, db DBTX, arg UpdateAccountAfterSpendParams) (UpdateAccountAfterSpendRow, error) {
	row := db.QueryRow(ctx, updateAccountAfterSpend, arg.ID, arg.BalancePoints)
	var i UpdateAccountAfterSpendRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicCode,
		&i.CreatedAt,
		&i.BalancePoints,
		&i.TotalSpendMoney,
		&i.LevelCode,
	)
	return i, err
}
