// ErrCode generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertEvent = `-- name: InsertEvent :one

INSERT INTO events (
    account_id, type, delta_points, balance_after,
    amount_money, ruleset_id, actor_user_id, ts
)
VALUES (
           $1,
           $2::event_type,
           $3,
           $4,
           $5,
           $6,
           $7,
           $8
       )
RETURNING
    id,
    account_id,
    type::text AS type,
    delta_points,
    balance_after,
    amount_money,
    ruleset_id,
    actor_user_id,
    ts,
    created_at
`

type InsertEventParams struct {
	AccountID    int64
	Column2      EventType
	DeltaPoints  int32
	BalanceAfter int32
	AmountMoney  pgtype.Numeric
	RulesetID    pgtype.Int8
	ActorUserID  pgtype.Int8
	Ts           pgtype.Timestamptz
}

type InsertEventRow struct {
	ID           int64
	AccountID    int64
	Type         string
	DeltaPoints  int32
	BalanceAfter int32
	AmountMoney  pgtype.Numeric
	RulesetID    pgtype.Int8
	ActorUserID  pgtype.Int8
	Ts           pgtype.Timestamptz
	CreatedAt    pgtype.Timestamptz
}

// internal/repository/postgres/sqlc/queries/events.sql
func (q *Queries) InsertEvent(ctx context.Context, db DBTX, arg InsertEventParams) (InsertEventRow, error) {
	row := db.QueryRow(ctx, insertEvent,
		arg.AccountID,
		arg.Column2,
		arg.DeltaPoints,
		arg.BalanceAfter,
		arg.AmountMoney,
		arg.RulesetID,
		arg.ActorUserID,
		arg.Ts,
	)
	var i InsertEventRow
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Type,
		&i.DeltaPoints,
		&i.BalanceAfter,
		&i.AmountMoney,
		&i.RulesetID,
		&i.ActorUserID,
		&i.Ts,
		&i.CreatedAt,
	)
	return i, err
}

const listEventsByAccount = `-- name: ListEventsByAccount :many
SELECT
    id,
    account_id,
    type::text AS type,
    delta_points,
    balance_after,
    amount_money,
    ruleset_id,
    actor_user_id,
    ts,
    created_at
FROM events
WHERE account_id = $1
ORDER BY ts DESC, id DESC
LIMIT $2
`

type ListEventsByAccountParams struct {
	AccountID int64
	Limit     int32
}

type ListEventsByAccountRow struct {
	ID           int64
	AccountID    int64
	Type         string
	DeltaPoints  int32
	BalanceAfter int32
	AmountMoney  pgtype.Numeric
	RulesetID    pgtype.Int8
	ActorUserID  pgtype.Int8
	Ts           pgtype.Timestamptz
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) ListEventsByAccount(ctx context.Context, db DBTX, arg ListEventsByAccountParams) ([]ListEventsByAccountRow, error) {
	rows, err := db.Query(ctx, listEventsByAccount, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventsByAccountRow
	for rows.Next() {
		var i ListEventsByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Type,
			&i.DeltaPoints,
			&i.BalanceAfter,
			&i.AmountMoney,
			&i.RulesetID,
			&i.ActorUserID,
			&i.Ts,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByAccountBefore = `-- name: ListEventsByAccountBefore :many
SELECT
    id,
    account_id,
    type::text AS type,
    delta_points,
    balance_after,
    amount_money,
    ruleset_id,
    actor_user_id,
    ts,
    created_at
FROM events
WHERE account_id = $1
  AND ts < $3
ORDER BY ts DESC, id DESC
LIMIT $2
`

type ListEventsByAccountBeforeParams struct {
	AccountID int64
	Limit     int32
	Ts        pgtype.Timestamptz
}

type ListEventsByAccountBeforeRow struct {
	ID           int64
	AccountID    int64
	Type         string
	DeltaPoints  int32
	BalanceAfter int32
	AmountMoney  pgtype.Numeric
	RulesetID    pgtype.Int8
	ActorUserID  pgtype.Int8
	Ts           pgtype.Timestamptz
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) ListEventsByAccountBefore(ctx context.Context, db DBTX, arg ListEventsByAccountBeforeParams) ([]ListEventsByAccountBeforeRow, error) {
	rows, err := db.Query(ctx, listEventsByAccountBefore, arg.AccountID, arg.Limit, arg.Ts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventsByAccountBeforeRow
	for rows.Next() {
		var i ListEventsByAccountBeforeRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Type,
			&i.DeltaPoints,
			&i.BalanceAfter,
			&i.AmountMoney,
			&i.RulesetID,
			&i.ActorUserID,
			&i.Ts,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
