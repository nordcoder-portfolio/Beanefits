// ErrCode generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rules.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const getRulesetByID = `-- name: GetRulesetByID :one
SELECT id, effective_from, base_rub_per_point, created_at
FROM ruleset
WHERE id = $1
`

type GetRulesetByIDRow struct {
	ID              int64
	EffectiveFrom   pgtype.Timestamptz
	BaseRubPerPoint decimal.Decimal
	CreatedAt       pgtype.Timestamptz
}

func (q *Queries) GetRulesetByID(ctx context.Context, db DBTX, id int64) (GetRulesetByIDRow, error) {
	row := db.QueryRow(ctx, getRulesetByID, id)
	var i GetRulesetByIDRow
	err := row.Scan(
		&i.ID,
		&i.EffectiveFrom,
		&i.BaseRubPerPoint,
		&i.CreatedAt,
	)
	return i, err
}

const getRulesetEffectiveAt = `-- name: GetRulesetEffectiveAt :one

SELECT id, effective_from, base_rub_per_point, created_at
FROM ruleset
WHERE effective_from <= $1
ORDER BY effective_from DESC
LIMIT 1
`

type GetRulesetEffectiveAtRow struct {
	ID              int64
	EffectiveFrom   pgtype.Timestamptz
	BaseRubPerPoint decimal.Decimal
	CreatedAt       pgtype.Timestamptz
}

// internal/repository/postgres/sqlc/queries/rules.sql
func (q *Queries) GetRulesetEffectiveAt(ctx context.Context, db DBTX, effectiveFrom pgtype.Timestamptz) (GetRulesetEffectiveAtRow, error) {
	row := db.QueryRow(ctx, getRulesetEffectiveAt, effectiveFrom)
	var i GetRulesetEffectiveAtRow
	err := row.Scan(
		&i.ID,
		&i.EffectiveFrom,
		&i.BaseRubPerPoint,
		&i.CreatedAt,
	)
	return i, err
}

const insertLevelRule = `-- name: InsertLevelRule :one
INSERT INTO level_rules (ruleset_id, level_code, threshold_total_spend, percent_earn)
VALUES ($1, $2, $3, $4)
RETURNING id, ruleset_id, level_code, threshold_total_spend, percent_earn
`

type InsertLevelRuleParams struct {
	RulesetID           int64
	LevelCode           string
	ThresholdTotalSpend decimal.Decimal
	PercentEarn         decimal.Decimal
}

func (q *Queries) InsertLevelRule(ctx context.Context, db DBTX, arg InsertLevelRuleParams) (LevelRule, error) {
	row := db.QueryRow(ctx, insertLevelRule,
		arg.RulesetID,
		arg.LevelCode,
		arg.ThresholdTotalSpend,
		arg.PercentEarn,
	)
	var i LevelRule
	err := row.Scan(
		&i.ID,
		&i.RulesetID,
		&i.LevelCode,
		&i.ThresholdTotalSpend,
		&i.PercentEarn,
	)
	return i, err
}

const insertRuleset = `-- name: InsertRuleset :one
INSERT INTO ruleset (effective_from, base_rub_per_point)
VALUES ($1, $2)
RETURNING id, effective_from, base_rub_per_point, created_at
`

type InsertRulesetParams struct {
	EffectiveFrom   pgtype.Timestamptz
	BaseRubPerPoint decimal.Decimal
}

type InsertRulesetRow struct {
	ID              int64
	EffectiveFrom   pgtype.Timestamptz
	BaseRubPerPoint decimal.Decimal
	CreatedAt       pgtype.Timestamptz
}

func (q *Queries) InsertRuleset(ctx context.Context, db DBTX, arg InsertRulesetParams) (InsertRulesetRow, error) {
	row := db.QueryRow(ctx, insertRuleset, arg.EffectiveFrom, arg.BaseRubPerPoint)
	var i InsertRulesetRow
	err := row.Scan(
		&i.ID,
		&i.EffectiveFrom,
		&i.BaseRubPerPoint,
		&i.CreatedAt,
	)
	return i, err
}

const listLevelRulesByRulesetID = `-- name: ListLevelRulesByRulesetID :many
SELECT id, ruleset_id, level_code, threshold_total_spend, percent_earn
FROM level_rules
WHERE ruleset_id = $1
ORDER BY threshold_total_spend ASC
`

func (q *Queries) ListLevelRulesByRulesetID(ctx context.Context, db DBTX, rulesetID int64) ([]LevelRule, error) {
	rows, err := db.Query(ctx, listLevelRulesByRulesetID, rulesetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LevelRule
	for rows.Next() {
		var i LevelRule
		if err := rows.Scan(
			&i.ID,
			&i.RulesetID,
			&i.LevelCode,
			&i.ThresholdTotalSpend,
			&i.PercentEarn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRulesetsBase = `-- name: ListRulesetsBase :many
SELECT id, effective_from, base_rub_per_point, created_at
FROM ruleset
ORDER BY effective_from DESC
LIMIT $1 OFFSET $2
`

type ListRulesetsBaseParams struct {
	Limit  int32
	Offset int32
}

type ListRulesetsBaseRow struct {
	ID              int64
	EffectiveFrom   pgtype.Timestamptz
	BaseRubPerPoint decimal.Decimal
	CreatedAt       pgtype.Timestamptz
}

func (q *Queries) ListRulesetsBase(ctx context.Context, db DBTX, arg ListRulesetsBaseParams) ([]ListRulesetsBaseRow, error) {
	rows, err := db.Query(ctx, listRulesetsBase, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRulesetsBaseRow
	for rows.Next() {
		var i ListRulesetsBaseRow
		if err := rows.Scan(
			&i.ID,
			&i.EffectiveFrom,
			&i.BaseRubPerPoint,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
